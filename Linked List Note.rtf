{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf600
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww16620\viewh17940\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\b\fs24 \cf0 Linked lists: 
\b0 uses pointers to organize and process data in lists\
	components (nodes) don\'92t need to be contiguous, order is determined by the address (link) stored in each node.\
	(except the last node) contains the address of the next node\
	head (first node) stored in a separate location\
	data type of pointer is the node type itself\
	\
Struct nodeType\{\
	int info;\
	nodeType * link;\
\};\
\
nodeType * head;\
Head -> link -> info stores the value of the 3rd component because head -> link points to the 3rd component\
Current = head; current and head both point to the 2nd component\
Current -> info = 2nd value\
Current -> link = 2nd pointer (to the 3rd component)\
Current -> link -> info 3rd value\
Current = current ->link; now current move on and point to the 3rd component\
\
Links are only 1 direction, always need the head to point the address of the 1st node; otherwise all of the nodes will be lost\
Use another pointer current.\
Current = head;\
While (current != nullptr)\{\
	//process current\
	current = current -> link (move on to the next component)\
\}\
\

\b Print Function outputs the data stored in each node:
\b0 \
While (current != nullptr)\{\
	cout << current -> info << endl;\
	current = current -> link;\
\}\
\
\

\b Insert a node\

\b0 nodeType * head;\
nodeType * current;\
nodeType * newNode;\
\

\b This method must follow every step:
\b0 \
Insert after p* component\
p* to 2nd node: 65 (#105)->(#107), 3rd node 34(#107)->(#109), need to insert a newNode between 65 and 34,\
newNode = new nodeType; create pointer newNode pointing to a node.\
newNode (#103) -> info = 50;\
newNode -> link = p-> link (copy the address of the 3rd node, so new (Node) is pointing to the 3rd node.\
P-> link = newNode (connect the gap, change 2nd node\'92s link address to new (Node)\
Now 2nd node -> new(Node) -> 3rd node\
\

\b This method is safer because order doesn\'92t matter
\b0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 p* to 2nd node: 65 (#105)->(#107), q* to 3rd node 34(#107)->(#109),\
newNode = new NodeType (#103);\
newNode ->info = 50\
newNode -> link = q, new (Node)\'92 s link = #107, link to the 3rd node\
P - > link = newNode, 2nd node 65(#105) now ->(#103) new (Node) \
\

\b Deletion\

\b0 p* to 2nd node 65(#105)->(#107)\
If p -> link = p -> link ->link 65(#105) is no longer point to (#107), but to the next node (#109)\
The memory is still occupied (the node still dangling)\
Need a pointer to this node\
Q = p -> link; q is pointing to 3rd node (#107)\
P -> link = q ->link 2nd node link the the 4th node (#109)\
Delete Q, delete pointer q will delete the memory it points to also.\
\

\b Building a Linked List - forward\

\b0 nodeType * buildListForward()\
\{
\b \

\b0 nodeType *head, *tail, *newNode\
Int num;\
*head = nullptr;\
*last = nullptr;\
While (num != -999) // quit with -999 (sentinel)\
\{\
	1. Cin >> num;\
	2. newNode = new nodeType;\
	3. newNode ->info = num;\
	4. newNode->link = nullptr (the newly inserted node new to always point to null)\
	5. If (head == nullptr) //if the list is empty before\
	\{\
		head = newNode //head is now point to the 1st node\
		tail = newNode //pointing to the last component\
	\}\
    	Else   //(head !=nullptr) \
	\{\
		tail ->link = newNode; //last component is link to the new (Node)\
		tail = newNode; // tail is again pointing to the last component	(newly inserted node)\
	\}\
\}\
Return head;\
\}\
\
\
\
\
\
\
}